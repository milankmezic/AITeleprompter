<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI Teleprompter</title>
  <!-- TailwindCSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
    };
  </script>
  <style>
    #teleprompter span.current {
        background-color: #4ade80; /* Tailwind green-400 */
        color: #fff;
        border-radius: 0.25rem;
        transition: background 0.2s, color 0.2s;
      }
    #teleprompter span.missed {
        background-color: #f87171; /* Tailwind red-400 */
        color: #fff;
        border-radius: 0.25rem;
        transition: background 0.2s, color 0.2s;
      }
    #teleprompter span.mismatched {
        background-color: transparent;
        color: inherit;
        border-radius: 0.25rem;
      }
      
            /* Toggle Switch Styles */
      input[type="checkbox"]:checked + label .dot {
        transform: translateX(16px);
        background-color: white !important;
      }
      input[type="checkbox"]:checked + label div:first-child {
        background-color: #3b82f6 !important; /* Tailwind blue-500 */
      }
      input[type="checkbox"]:not(:checked) + label div:first-child {
        background-color: #9ca3af !important; /* Tailwind gray-400 */
      }
      input[type="checkbox"]:not(:checked) + label .dot {
        background-color: white !important;
      }
      
      /* Ensure proper toggle appearance */
      .relative .w-10.h-6 {
        border-radius: 9999px !important;
        transition: background-color 0.3s ease-in-out;
      }
      
      /* Ensure the dot is visible and properly positioned */
      .dot {
        position: absolute !important;
        left: 2px !important;
        top: 2px !important;
        width: 16px !important;
        height: 16px !important;
        border-radius: 50% !important;
        background-color: white !important;
        transition: transform 0.3s ease-in-out;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        z-index: 10;
      }
      
      /* Force white background on all dots regardless of state */
      input[type="checkbox"] + label .dot {
        background-color: white !important;
      }
      
      /* Override any inherited background colors */
      .dot[style*="background"] {
        background-color: white !important;
      }
      
      /* Click-to-speak word styling */
      #teleprompter span[id^="w"] {
        cursor: pointer;
        transition: all 0.2s ease-in-out;
        border-radius: 4px;
        padding: 2px 4px;
        margin: 1px;
      }
      
      #teleprompter span[id^="w"]:hover {
        background-color: rgba(59, 130, 246, 0.1) !important;
        transform: scale(1.05);
      }
      
      #teleprompter span[id^="w"]:active {
        background-color: rgba(59, 130, 246, 0.2) !important;
        transform: scale(0.98);
      }
      
      /* Success message styling */
      .success-message {
        animation: fadeIn 0.3s ease-in-out;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
      }
  </style>
</head>
<body class="bg-gradient-to-br from-indigo-400 to-purple-600 dark:from-gray-900 dark:to-gray-800 text-white dark:text-white min-h-screen overflow-hidden transition-colors duration-300">
  <!-- Splash Screen -->
  <div id="splash-screen" class="screen flex flex-col justify-center items-center h-screen w-screen text-center">
    <div class="logo text-6xl font-bold mb-4 drop-shadow-lg">📺 AI Teleprompter</div>
    <div class="subtitle text-2xl mb-12 opacity-90">Professional speech assistance powered by AI</div>
    <button class="btn bg-white/20 border-2 border-white text-white px-8 py-4 text-xl rounded-full cursor-pointer transition hover:bg-white hover:text-indigo-500 hover:shadow-lg mb-8 backdrop-blur dark:bg-white/10 dark:border-white/40 dark:hover:bg-white/20 dark:hover:text-indigo-300" onclick="showSettings()">Get Started</button>
    <div class="github-link absolute bottom-8 left-1/2 -translate-x-1/2 opacity-80 hover:opacity-100 transition">
      <a href="https://github.com/milankmezic/AITeleprompter" target="_blank" rel="noopener noreferrer" class="text-white no-underline text-base px-4 py-2 border border-white/30 rounded-full bg-white/10 backdrop-blur hover:bg-white/20 hover:-translate-y-0.5 hover:shadow-lg transition dark:bg-white/5 dark:border-white/20 dark:hover:bg-white/10">🔗 Get Latest Version on GitHub</a>
    </div>
  </div>
  <!-- Settings Screen -->
  <div id="settings-screen" class="screen hidden flex-col items-center justify-start min-h-screen w-full p-8 overflow-y-auto dark:bg-gray-900">
    <div class="settings-container bg-white/10 dark:bg-white/5 rounded-2xl p-8 w-full max-w-5xl min-h-[calc(100vh-4rem)] flex flex-col backdrop-blur border border-white/20 dark:border-white/10">
      <div class="settings-header mb-8 text-center">
        <h2 class="settings-title text-4xl mb-2">Setup Your Script</h2>
        <p class="settings-subtitle text-lg opacity-90 mb-8">Configure your teleprompter settings and enter your script</p>
        <div id="error-container"></div>
      </div>
      <div class="settings-content flex flex-col gap-6 flex-1 mb-8">
        <div class="form-group flex-1 flex flex-col">
          <label for="script-text" class="mb-2 text-base font-medium">Your Script:</label>
          <div class="mb-4 flex gap-2">
            <input type="url" id="script-url" placeholder="Enter URL, file path, or local file..." class="flex-1 px-3 py-2 rounded-lg bg-white/90 text-gray-800 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-300" />
            <button id="load-url-btn" class="px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition text-sm">Load URL</button>
            <input type="file" id="script-file" accept=".txt,.md,.doc,.docx" class="hidden" />
            <button id="load-file-btn" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition text-sm">Load File</button>
          </div>
          <textarea id="script-text" placeholder="Enter your script here... The teleprompter will follow your speech and highlight words as you speak them." class="min-h-[300px] p-4 rounded-lg bg-white/90 text-gray-800 text-base resize-none font-sans focus:outline-none focus:ring-2 focus:ring-indigo-300"></textarea>
          <div id="script-stats" class="mt-2 text-sm text-white/80 flex gap-4">
            <span id="word-count">Words: 0</span>
            <span id="reading-time">Estimated reading time: 0:00</span>
          </div>
        </div>
        <div class="btn-group flex gap-4 justify-center">
          <button class="btn btn-secondary bg-white/10 border-2 border-white/20 text-white px-8 py-4 text-xl rounded-full cursor-pointer transition hover:bg-white/20 hover:text-white" onclick="showSplash()">Back</button>
          <button class="btn bg-white/20 border-2 border-white text-white px-8 py-4 text-xl rounded-full cursor-pointer transition hover:bg-white hover:text-indigo-500 hover:shadow-lg" onclick="startTeleprompter()">Start Teleprompter</button>
          <button id="speech-analysis-btn" class="btn bg-indigo-500 border-2 border-indigo-400 text-white px-8 py-4 text-xl rounded-full cursor-pointer transition hover:bg-indigo-600 hover:shadow-lg" onclick="showLatestAnalysis()" style="display: none;">Speech Analysis</button>
        </div>
        <button id="advanced-settings-toggle" type="button" class="text-indigo-200 hover:text-indigo-400 underline text-base focus:outline-none text-center">Show Advanced Settings</button>
      </div>
    </div>
  </div>
  <!-- Advanced Settings Screen -->
  <div id="advanced-settings-screen" class="screen hidden flex flex-col items-center justify-start min-h-screen w-full p-8 overflow-y-auto dark:bg-gray-900">
    <div class="settings-container bg-white/10 dark:bg-white/5 rounded-2xl p-8 w-full max-w-3xl flex flex-col backdrop-blur border border-white/20 dark:border-white/10">
      <div class="settings-header mb-8 text-center">
        <h2 class="settings-title text-3xl mb-2">Advanced Settings</h2>
        <p class="settings-subtitle text-lg opacity-90 mb-8">Fine-tune your teleprompter experience</p>
      </div>
      <div class="settings-content flex flex-col gap-4">
                <!-- Dark Mode -->
        <div class="form-group mb-4 flex items-center gap-3">
          <label for="theme-toggle" class="text-base font-medium mb-0">🌙 Dark Mode</label>
          <div class="relative">
            <input type="checkbox" id="theme-toggle" class="sr-only">
            <label for="theme-toggle" class="flex items-center cursor-pointer">
              <div class="relative w-10 h-6 bg-gray-400 rounded-full shadow-inner">
                <div class="dot" style="background-color: white !important;"></div>
              </div>
            </label>
          </div>
        </div>
          
                <!-- Word Highlights -->
        <div class="form-group mb-4 flex items-center gap-3">
          <label for="highlight-toggle" class="text-base font-medium mb-0">🎨 Word Highlights</label>
          <div class="relative">
            <input type="checkbox" id="highlight-toggle" checked class="sr-only">
            <label for="highlight-toggle" class="flex items-center cursor-pointer">
              <div class="relative w-10 h-6 bg-gray-400 rounded-full shadow-inner">
                <div class="dot" style="background-color: white !important;"></div>
              </div>
            </label>
          </div>
        </div>
        <small class="opacity-80 text-sm mb-4 block">Show red highlights for missed words</small>

        <!-- Font Size -->
        <div class="form-group mb-4">
          <label for="font-size" class="text-base font-medium mb-0">Font Size:</label>
          <select id="font-size" class="px-4 py-2 rounded-lg bg-white/90 text-gray-800 text-base font-normal cursor-pointer transition focus:outline-none focus:ring-2 focus:ring-indigo-300">
            <option value="text-2xl">Small</option>
            <option value="text-3xl" selected>Medium</option>
            <option value="text-4xl">Large</option>
            <option value="text-5xl">Extra Large</option>
          </select>
        </div>

        <!-- Current Word Position -->
        <div class="form-group mb-4">
          <label for="scroll-position" class="text-base font-medium mb-0">Current Word Position:</label>
          <select id="scroll-position" class="px-4 py-2 rounded-lg bg-white/90 text-gray-800 text-base font-normal cursor-pointer transition focus:outline-none focus:ring-2 focus:ring-indigo-300">
                <option value="top">📄 Top of Screen</option>
                <option value="middle" selected>🎯 Center of Screen</option>
                <option value="bottom">📋 Bottom of Screen</option>
              </select>
          </div>
          
                <!-- Mirror Mode -->
        <div class="form-group mb-4 flex items-center gap-3">
          <label for="mirror-mode" class="text-base font-medium mb-0">Mirror Mode</label>
          <div class="relative">
            <input id="mirror-mode" type="checkbox" class="sr-only">
            <label for="mirror-mode" class="flex items-center cursor-pointer">
              <div class="relative w-10 h-6 bg-gray-400 rounded-full shadow-inner">
                <div class="dot" style="background-color: white !important;"></div>
              </div>
            </label>
          </div>
        </div>
        
        <!-- Reset to Defaults -->
        <div class="form-group mb-2">
          <button id="reset-defaults" class="btn bg-red-500 text-white px-4 py-2 rounded-full hover:bg-red-700 transition">Reset to Defaults</button>
          </div>
        <div class="btn-group flex gap-4 justify-center mt-8">
          <button class="btn btn-secondary bg-white/10 border-2 border-white/20 text-white px-8 py-4 text-xl rounded-full cursor-pointer transition hover:bg-white/20 hover:text-white" onclick="showSettings()">Back</button>
        </div>
      </div>
    </div>
  </div>
  <!-- Teleprompter Screen -->
  <div id="teleprompter-screen" class="screen hidden flex flex-col justify-start items-center min-h-screen w-full bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white p-0">
    <button class="back-btn absolute top-8 left-8 bg-white/20 border border-white/30 text-indigo-700 dark:text-indigo-300 px-4 py-2 rounded-full cursor-pointer transition hover:bg-white/40 z-10" onclick="showSettings()">← Back to Settings</button>
    <div id="teleprompter" class="w-full h-screen overflow-y-auto px-8 pt-32 pb-8 leading-relaxed text-3xl bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-white font-medium scroll-py-8"></div>
    <button id="startBtn" class="floating-start-btn fixed bottom-8 left-1/2 -translate-x-1/2 bg-indigo-500 dark:bg-indigo-700 text-white px-8 py-4 text-xl rounded-full shadow-lg cursor-pointer transition hover:bg-indigo-700 dark:hover:bg-indigo-900 z-20">Start Speaking</button>
  </div>

  <!-- Analysis Modal -->
  <div id="analysis-modal" class="analysis-modal hidden fixed inset-0 bg-black/80 flex justify-center items-center z-50 backdrop-blur">
    <div class="analysis-content bg-white/10 dark:bg-white/5 border-2 border-white/20 dark:border-white/10 rounded-2xl p-8 max-w-xl w-full max-h-[80vh] overflow-y-auto backdrop-blur text-white">
      <div class="analysis-header text-center mb-8">
        <h2 class="analysis-title text-4xl flex items-center justify-center gap-2 mb-2"><span>📊</span><span>Speech Analysis</span></h2>
        <p class="analysis-subtitle text-lg opacity-90">Your teleprompter performance summary</p>
      </div>
      <div class="stats-grid grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8">
        <div class="stat-card bg-white/20 border-2 border-white/30 rounded-xl p-6 text-center transition hover:shadow-lg">
          <span class="stat-number text-3xl font-bold block mb-2" id="total-words">0</span>
          <span class="stat-label text-sm opacity-80">Total Words</span>
        </div>
        <div class="stat-card bg-white/20 border-2 border-white/30 rounded-xl p-6 text-center transition hover:shadow-lg">
          <span class="stat-number text-3xl font-bold block mb-2" id="correct-words">0</span>
          <span class="stat-label text-sm opacity-80">Correct Words</span>
        </div>
        <div class="stat-card bg-white/20 border-2 border-white/30 rounded-xl p-6 text-center transition hover:shadow-lg">
          <span class="stat-number text-3xl font-bold block mb-2" id="missed-words">0</span>
          <span class="stat-label text-sm opacity-80">Missed Words</span>
        </div>
      </div>
      <div class="accuracy-bar bg-white/20 rounded-lg h-6 my-4 overflow-hidden relative">
        <div class="accuracy-fill bg-gradient-to-r from-green-500 to-lime-400 h-full transition-all duration-700" id="accuracy-fill">
          <div class="accuracy-text absolute inset-0 flex items-center justify-center text-sm font-bold text-white drop-shadow" id="accuracy-text">0%</div>
        </div>
      </div>
      <div class="stats-grid grid grid-cols-1 sm:grid-cols-2 gap-4 mb-8">
        <div class="stat-card bg-white/20 border-2 border-white/30 rounded-xl p-6 text-center transition hover:shadow-lg">
          <span class="stat-number text-2xl font-bold block mb-2" id="analysis-reading-time">0:00</span>
          <span class="stat-label text-sm opacity-80">Reading Time</span>
        </div>
        <div class="stat-card bg-white/20 border-2 border-white/30 rounded-xl p-6 text-center transition hover:shadow-lg">
          <span class="stat-number text-2xl font-bold block mb-2" id="reading-speed">0</span>
          <span class="stat-label text-sm opacity-80">Words per Minute</span>
        </div>
      </div>
      <div class="analysis-actions flex gap-4 justify-center mt-8">
        <button class="modal-btn secondary bg-white/20 border-2 border-white/30 text-white px-6 py-2 rounded-full cursor-pointer transition hover:bg-white/40" onclick="closeAnalysis()">Close</button>
        <button class="modal-btn primary bg-indigo-500 text-white px-6 py-2 rounded-full cursor-pointer transition hover:bg-indigo-700" onclick="restartTeleprompter()">Read Again</button>
      </div>
    </div>
  </div>

  <script>
    // Local storage keys
    const STORAGE_KEY = 'teleprompter_script';
    const THEME_KEY = 'teleprompter_theme';
    const SCROLL_POSITION_KEY = 'teleprompter_scroll_position';
    const HIGHLIGHT_KEY = 'teleprompter_highlight_enabled';
    
    // Global variables
    let currentScreen = 'splash';
    let currentWordIndex = 0;
    let words = [];
    let recognition = null;
    let spokenWords = [];
    let isListening = false;
    let scrollingInterval = null;
    let scrollPosition = 'middle'; // 'top', 'middle', 'bottom'
    let isManualScrolling = false;
    let manualScrollTimeout = null;
    let highlightEnabled = true;
    
    // Speech analysis variables
    let speechStats = {
      totalWords: 0,
      correctWords: 0,
      missedWords: 0,
      mismatchedWords: 0,
      startTime: null,
      endTime: null
    };



    // Mirror mode functions
    const MIRROR_MODE_KEY = 'teleprompter_mirror_mode';
    function saveMirrorMode(enabled) {
      localStorage.setItem(MIRROR_MODE_KEY, enabled ? 'true' : 'false');
    }
    function loadMirrorMode() {
      const saved = localStorage.getItem(MIRROR_MODE_KEY);
      const mirrorCheckbox = document.getElementById('mirror-mode');
      const teleprompter = document.getElementById('teleprompter');
      const enabled = saved === 'true';
      if (mirrorCheckbox) mirrorCheckbox.checked = enabled;
      applyMirrorMode(enabled);
    }
    function applyMirrorMode(enabled) {
      const teleprompter = document.getElementById('teleprompter');
      if (!teleprompter) return;
      teleprompter.style.transform = enabled ? 'scaleX(-1)' : '';
    }
    function updateMirrorMode() {
      const mirrorCheckbox = document.getElementById('mirror-mode');
      if (mirrorCheckbox) {
        saveMirrorMode(mirrorCheckbox.checked);
        applyMirrorMode(mirrorCheckbox.checked);
      }
    }

    // Screen navigation
    function showScreen(screenId) {
      document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.add('hidden');
        screen.classList.remove('flex');
      });
      const activeScreen = document.getElementById(screenId + '-screen');
      activeScreen.classList.remove('hidden');
      activeScreen.classList.add('flex');
      currentScreen = screenId;
    }

    function showSplash() {
      showScreen('splash');
    }

    function showSettings() {
      showScreen('settings');
      loadScript();
      loadScrollPosition();
      loadHighlightEnabled();
      loadFontSize();
      loadMirrorMode();
      loadTheme();
      
      // Set up theme toggle if not already done
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle && !themeToggle.hasAttribute('data-listener')) {
        themeToggle.addEventListener('change', toggleTheme);
        themeToggle.setAttribute('data-listener', 'true');
        // Ensure the toggle reflects the current theme
        const currentTheme = localStorage.getItem(THEME_KEY) || 'light';
        themeToggle.checked = currentTheme === 'dark';
      }
      
      // Set up highlight toggle if not already done
      const highlightToggle = document.getElementById('highlight-toggle');
      if (highlightToggle && !highlightToggle.hasAttribute('data-listener')) {
        highlightToggle.addEventListener('change', updateHighlightEnabled);
        highlightToggle.setAttribute('data-listener', 'true');
      }
      
      // Set up scroll position selector if not already done
      const scrollSelect = document.getElementById('scroll-position');
      if (scrollSelect && !scrollSelect.hasAttribute('data-listener')) {
        scrollSelect.addEventListener('change', updateScrollPosition);
        scrollSelect.setAttribute('data-listener', 'true');
      }
      // Set up font size selector if not already done
      const fontSizeSelect = document.getElementById('font-size');
      if (fontSizeSelect && !fontSizeSelect.hasAttribute('data-listener')) {
        fontSizeSelect.addEventListener('change', updateFontSize);
        fontSizeSelect.setAttribute('data-listener', 'true');
      }
      // Set up mirror mode selector if not already done
      const mirrorCheckbox = document.getElementById('mirror-mode');
      if (mirrorCheckbox && !mirrorCheckbox.hasAttribute('data-listener')) {
        mirrorCheckbox.addEventListener('change', updateMirrorMode);
        mirrorCheckbox.setAttribute('data-listener', 'true');
      }
      
      // Check if there's existing analysis data to show the Speech Analysis button
      const analysisData = localStorage.getItem('teleprompter_analysis');
      if (analysisData) {
        const analysisBtn = document.getElementById('speech-analysis-btn');
        if (analysisBtn) {
          analysisBtn.style.display = 'inline-block';
        }
      }
      
    }

    function showTeleprompter() {
      showScreen('teleprompter');
    }

    // Local storage functions
    function saveScript(text) {
      localStorage.setItem(STORAGE_KEY, text);
    }

    function loadScript() {
      const savedScript = localStorage.getItem(STORAGE_KEY);
      if (savedScript) {
        document.getElementById('script-text').value = savedScript;
      }
      updateScriptStats();
    }

    // Script statistics functions
    function updateScriptStats() {
      const scriptText = document.getElementById('script-text').value;
      const words = scriptText.trim() ? scriptText.trim().split(/\s+/).length : 0;
      const wordCountElement = document.getElementById('word-count');
      const readingTimeElement = document.getElementById('reading-time');
      
      wordCountElement.textContent = `Words: ${words}`;
      
      // Calculate reading time (assuming average 150 words per minute)
      const wordsPerMinute = 150;
      const minutes = Math.floor(words / wordsPerMinute);
      const seconds = Math.floor((words % wordsPerMinute) / (wordsPerMinute / 60));
      const timeString = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      readingTimeElement.textContent = `Estimated reading time: ${timeString}`;
    }

    // URL loading functions
    async function loadScriptFromURL(url) {
      try {
        // Show loading state
        const loadBtn = document.getElementById('load-url-btn');
        const originalText = loadBtn.textContent;
        loadBtn.textContent = 'Loading...';
        loadBtn.disabled = true;
        
        let content;
        
        // Handle different URL types
        if (url.startsWith('file://') || url.startsWith('http://') || url.startsWith('https://')) {
          // Try to fetch from web URL or local file
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            content = await response.text();
          } catch (corsError) {
            // CORS error - provide alternative solutions
            if (corsError.message.includes('CORS') || corsError.message.includes('blocked')) {
              throw new Error(`CORS blocked: ${url}. Try using a CORS proxy or hosting the file on a server with CORS headers.`);
            }
            throw corsError;
          }
        } else {
          // Handle local file path (relative or absolute)
          try {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(`File not found: ${url}`);
            }
            content = await response.text();
          } catch (localError) {
            // If local fetch fails, try as a relative path
            try {
              const relativeUrl = url.startsWith('/') ? url : `/${url}`;
              const response = await fetch(relativeUrl);
              if (!response.ok) {
                throw new Error(`File not found: ${url}`);
              }
              content = await response.text();
            } catch (finalError) {
              throw new Error(`File not found: ${url}. Make sure the file exists and is accessible.`);
            }
          }
        }
        
        // Load the content into the textarea
        document.getElementById('script-text').value = content;
        
        // Update stats
        updateScriptStats();
        
        // Save to local storage
        saveScript(content);
        
        // Show success message
        showSuccess('Script loaded successfully!');
        
      } catch (error) {
        // Provide helpful error message with solutions
        if (error.message.includes('CORS')) {
          showError(`CORS Error: ${error.message}

Solutions:
1. Use a CORS proxy: https://cors-anywhere.herokuapp.com/your-url
2. Host the file on a server with CORS headers
3. Use a local file instead
4. Copy the content directly into the textarea`);
        } else {
          showError(`Failed to load script: ${error.message}`);
        }
      } finally {
        // Reset button state
        const loadBtn = document.getElementById('load-url-btn');
        loadBtn.textContent = 'Load URL';
        loadBtn.disabled = false;
      }
    }

    function showSuccess(message) {
      const errorContainer = document.getElementById('error-container');
      errorContainer.innerHTML = `<div class="success-message text-green-300 bg-green-900/20 border border-green-500/30 rounded-lg px-4 py-2 mb-4">${message}</div>`;
      setTimeout(() => {
        errorContainer.innerHTML = '';
      }, 3000);
    }

    // File loading function (no CORS issues)
    function loadScriptFromFile(file) {
      const reader = new FileReader();
      
      reader.onload = function(e) {
        const content = e.target.result;
        
        // Load the content into the textarea
        document.getElementById('script-text').value = content;
        
        // Update stats
        updateScriptStats();
        
        // Save to local storage
        saveScript(content);
        
        // Show success message
        showSuccess(`Script loaded successfully from file: ${file.name}`);
      };
      
      reader.onerror = function() {
        showError('Failed to read the file. Please try again.');
      };
      
      // Read the file as text
      reader.readAsText(file);
    }

    // Speech analysis functions
    function showLatestAnalysis() {
      const analysisData = localStorage.getItem('teleprompter_analysis');
      if (analysisData) {
        const data = JSON.parse(analysisData);
        // Display the saved analysis data directly without recalculating
        displayAnalysis(data);
        // Show the modal
        document.getElementById('analysis-modal').classList.remove('hidden');
        document.getElementById('analysis-modal').classList.add('flex');
      } else {
        alert('No previous analysis available.');
      }
    }

    function saveAnalysisData(data) {
      localStorage.setItem('teleprompter_analysis', JSON.stringify(data));
      // Show the speech analysis button if we have analysis data
      const analysisBtn = document.getElementById('speech-analysis-btn');
      if (analysisBtn) {
        analysisBtn.style.display = 'inline-block';
      }
    }

    // Theme functions
    function getSystemTheme() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    function getSavedTheme() {
      return localStorage.getItem(THEME_KEY) || getSystemTheme();
    }

    function saveTheme(theme) {
      localStorage.setItem(THEME_KEY, theme);
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem(THEME_KEY);
      if (savedTheme) {
        applyTheme(savedTheme);
      } else {
        // Default to system preference or light theme
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        applyTheme(prefersDark ? 'dark' : 'light');
      }
    }

    function applyTheme(theme) {
      if (theme === 'dark') {
        document.documentElement.classList.add('dark');
      } else {
        document.documentElement.classList.remove('dark');
      }
      const themeToggle = document.getElementById('theme-toggle');
      if (themeToggle) {
        themeToggle.checked = theme === 'dark';
      }
    }

    function toggleTheme() {
      const isDark = document.documentElement.classList.contains('dark');
      const newTheme = isDark ? 'light' : 'dark';
      applyTheme(newTheme);
      saveTheme(newTheme);
    }

    // Scroll position functions
    function saveScrollPosition(position) {
      localStorage.setItem(SCROLL_POSITION_KEY, position);
      scrollPosition = position;
    }

    function loadScrollPosition() {
      const savedPosition = localStorage.getItem(SCROLL_POSITION_KEY) || 'middle';
      scrollPosition = savedPosition;
      const scrollSelect = document.getElementById('scroll-position');
      if (scrollSelect) {
        scrollSelect.value = savedPosition;
      }
    }

    function updateScrollPosition() {
      const scrollSelect = document.getElementById('scroll-position');
      if (scrollSelect) {
        saveScrollPosition(scrollSelect.value);
      }
    }

    // Highlight functions
    function saveHighlightEnabled(enabled) {
      localStorage.setItem(HIGHLIGHT_KEY, enabled.toString());
      highlightEnabled = enabled;
    }

    function loadHighlightEnabled() {
      const saved = localStorage.getItem(HIGHLIGHT_KEY);
      highlightEnabled = saved === null ? true : saved === 'true';
      const highlightToggle = document.getElementById('highlight-toggle');
      if (highlightToggle) {
        highlightToggle.checked = highlightEnabled;
      }
    }

    function updateHighlightEnabled() {
      const highlightToggle = document.getElementById('highlight-toggle');
      if (highlightToggle) {
        saveHighlightEnabled(highlightToggle.checked);
        
        // If highlighting is disabled, clear existing highlights
        if (!highlightToggle.checked) {
          clearHighlights();
        }
      }
    }

    // Font size functions
    const FONT_SIZE_KEY = 'teleprompter_font_size';
    function saveFontSize(size) {
      localStorage.setItem(FONT_SIZE_KEY, size);
    }
    function loadFontSize() {
      const saved = localStorage.getItem(FONT_SIZE_KEY) || 'text-3xl';
      const fontSizeSelect = document.getElementById('font-size');
      if (fontSizeSelect) fontSizeSelect.value = saved;
      applyFontSize(saved);
    }
    function applyFontSize(size) {
      const teleprompter = document.getElementById('teleprompter');
      if (!teleprompter) return;
      teleprompter.classList.remove('text-2xl', 'text-3xl', 'text-4xl', 'text-5xl');
      teleprompter.classList.add(size);
    }
    function updateFontSize() {
      const fontSizeSelect = document.getElementById('font-size');
      if (fontSizeSelect) {
        saveFontSize(fontSizeSelect.value);
        applyFontSize(fontSizeSelect.value);
      }
    }

    // Clear all missed and mismatched highlights (but keep current word highlight)
    function clearHighlights() {
      document.querySelectorAll('#teleprompter span').forEach(span => {
        span.classList.remove('missed', 'mismatched');
        // Also clear inline styles
        span.style.backgroundColor = '';
        span.style.color = '';
      });
    }

    // Clear mismatched highlights from a specific position forward (when user goes back to repeat)
    function clearMismatchedHighlightsForward(fromIndex) {
      let clearedCount = 0;
      for (let i = fromIndex; i < currentWordIndex; i++) {
        const target = document.getElementById('w' + i);
        if (target && target.classList.contains('mismatched')) {
          target.classList.remove('mismatched');
          // Clear inline styles if any
          if (target.style.backgroundColor && target.style.backgroundColor !== 'rgb(244, 67, 54)') {
            target.style.backgroundColor = '';
            target.style.color = '';
          }
          clearedCount++;
          console.log('Cleared mismatched highlight for word:', i, target.textContent);
        }
      }
      
      // Adjust statistics - remove cleared mismatched words from count
      speechStats.mismatchedWords = Math.max(0, speechStats.mismatchedWords - clearedCount);
      
      if (clearedCount > 0) {
        console.log('Cleared', clearedCount, 'mismatched highlights from position', fromIndex, 'forward');
      }
    }

    // Initialize speech statistics
    function initializeSpeechStats() {
      speechStats = {
        totalWords: words.length,
        correctWords: 0,
        missedWords: 0,
        mismatchedWords: 0,
        startTime: new Date(),
        endTime: null
      };
    }

    // Update button based on progress
    function updateStartButton() {
      const startBtn = document.getElementById('startBtn');
      if (currentWordIndex >= words.length) {
        // Reached the end
        if (speechStats.endTime === null) {
          speechStats.endTime = new Date();
        }
        startBtn.textContent = 'View Analysis';
        startBtn.disabled = false;
      } else if (isListening) {
        startBtn.textContent = 'Pause Listening';
        startBtn.disabled = false;
      } else {
        startBtn.textContent = 'Start Speaking';
        startBtn.disabled = false;
      }
    }

    // Show analysis modal
    function showAnalysis() {
      // Calculate statistics
      const totalTime = speechStats.endTime - speechStats.startTime;
      const minutes = Math.floor(totalTime / 60000);
      const seconds = Math.floor((totalTime % 60000) / 1000);
      // Handle very short durations (less than 1 second)
      const readingTime = totalTime < 1000 ? '0:01' : `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Calculate correct words as total minus only missed words (mismatched words count as correct)
      speechStats.correctWords = speechStats.totalWords - speechStats.missedWords;
      
      const accuracy = speechStats.totalWords > 0 ? Math.round((speechStats.correctWords / speechStats.totalWords) * 100) : 0;
      const wordsPerMinute = totalTime > 0 ? Math.round((speechStats.totalWords / totalTime) * 60000) : 0;
      
      // Create analysis data object
      const analysisData = {
        totalWords: speechStats.totalWords,
        correctWords: speechStats.correctWords,
        missedWords: speechStats.missedWords,
        accuracy,
        readingTime,
        wordsPerMinute,
        timestamp: new Date().toISOString()
      };
      
      // Save analysis data
      saveAnalysisData(analysisData);
      
      // Update modal content
      displayAnalysis(analysisData);
      
      // Show modal
      document.getElementById('analysis-modal').classList.remove('hidden');
      document.getElementById('analysis-modal').classList.add('flex');
    }

    function displayAnalysis(data) {
      document.getElementById('total-words').textContent = data.totalWords;
      document.getElementById('correct-words').textContent = data.correctWords;
      document.getElementById('missed-words').textContent = data.missedWords;
      document.getElementById('analysis-reading-time').textContent = data.readingTime;
      document.getElementById('reading-speed').textContent = data.wordsPerMinute;
      
      // Update accuracy bar
      const accuracyFill = document.getElementById('accuracy-fill');
      const accuracyText = document.getElementById('accuracy-text');
      accuracyFill.style.width = data.accuracy + '%';
      accuracyText.textContent = data.accuracy + '%';
    }

    // Close analysis modal
    function closeAnalysis() {
      document.getElementById('analysis-modal').classList.add('hidden');
      document.getElementById('analysis-modal').classList.remove('flex');
    }

    // Restart teleprompter
    function restartTeleprompter() {
      closeAnalysis();
      currentWordIndex = 0;
      isListening = false;
      stopContinuousScrolling();
      
      // Clear all highlights
      document.querySelectorAll('#teleprompter span').forEach(s => {
        s.classList.remove('current', 'missed', 'mismatched');
      });
      
      // Reset statistics
      initializeSpeechStats();
      
      // Update button and highlight first word
      updateStartButton();
      highlightCurrentWord();
    }

    // Speech synthesis for click-to-speak functionality
    function speakWord(word) {
      if ('speechSynthesis' in window) {
        // Cancel any ongoing speech
        speechSynthesis.cancel();
        
        // Create a new speech utterance
        const utterance = new SpeechSynthesisUtterance(word);
        
        // Configure speech settings
        utterance.rate = 0.8; // Slightly slower for clarity
        utterance.pitch = 1.0; // Normal pitch
        utterance.volume = 0.8; // Good volume
        
        // Get the current language setting or default to English
        const languageSelect = document.getElementById('language-select');
        if (languageSelect) {
          utterance.lang = languageSelect.value || 'en-US';
        } else {
          utterance.lang = 'en-US';
        }
        
        // Speak the word
        speechSynthesis.speak(utterance);
        
        // Optional: Add visual feedback
        const clickedSpan = event.target;
        if (clickedSpan) {
          clickedSpan.style.backgroundColor = '#3b82f6'; // Blue highlight
          clickedSpan.style.color = 'white';
          setTimeout(() => {
            clickedSpan.style.backgroundColor = '';
            clickedSpan.style.color = '';
          }, 500);
        }
      } else {
        // Speech synthesis not supported
      }
    }

    // Error handling
    function showError(message) {
      const errorContainer = document.getElementById('error-container');
      errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
      setTimeout(() => {
        errorContainer.innerHTML = '';
      }, 5000);
    }

    // Teleprompter functions
    function startTeleprompter() {
      const scriptText = document.getElementById('script-text').value.trim();
      
      if (!scriptText) {
        showError('Please enter some text for your teleprompter script.');
        return;
      }

      // Save script to local storage
      saveScript(scriptText);

      // Setup teleprompter
      setupTeleprompter(scriptText);
      showTeleprompter();
    }

    function setupTeleprompter(scriptText) {
    const container = document.getElementById('teleprompter');
      const startBtn = document.getElementById('startBtn');
      
      // Reset state
      currentWordIndex = 0;
      spokenWords = [];
      isListening = false;

          // Wrap each word in a span with an ID while preserving line breaks
      words = scriptText.split(/\s+/).filter(word => word.trim() !== '');
      
      // Process the original text to preserve line breaks and spacing
      let processedHTML = '';
      let wordIndex = 0;
      let i = 0;
      
      while (i < scriptText.length) {
        const char = scriptText[i];
        
        // Check if we're at the start of a word
        if (char.match(/\S/)) {
          // Find the complete word
          let wordEnd = i;
          while (wordEnd < scriptText.length && scriptText[wordEnd].match(/\S/)) {
            wordEnd++;
          }
          
          const word = scriptText.substring(i, wordEnd);
          
          // Wrap the word in a span
          if (wordIndex < words.length) {
            processedHTML += `<span id="w${wordIndex}">${word}</span>`;
            wordIndex++;
          }
          
          i = wordEnd;
        } else {
          // Handle whitespace and line breaks
          if (char === '\n') {
            processedHTML += '<br/>';
          } else if (char === ' ' || char === '\t') {
            processedHTML += ' ';
          }
          i++;
        }
      }
      
      // Add a full page of blank space at the end to ensure scrolling always works
      const viewportHeight = window.innerHeight;
      const blankSpaceHeight = viewportHeight * 1.5; // 1.5x viewport height for extra space
      const blankSpace = `<div style="height: ${blankSpaceHeight}px;"></div>`;
      
      container.innerHTML = processedHTML + blankSpace;
      
      // Add click-to-speak functionality to all word spans
      document.querySelectorAll('#teleprompter span[id^="w"]').forEach(span => {
        span.style.cursor = 'pointer';
        span.addEventListener('click', function() {
          speakWord(this.textContent);
        });
      });

      // Clear any existing highlighting classes
      document.querySelectorAll('#teleprompter span').forEach(s => {
        s.classList.remove('current', 'missed', 'mismatched');
      });

      // Initialize speech statistics
      initializeSpeechStats();

      // Reset start button and stop any existing recognition
      if (recognition) {
        recognition.stop();
        recognition = null;
      }
      isListening = false;
      stopContinuousScrolling();
      
      // Update button and highlight first word
      updateStartButton();
      highlightCurrentWord();
      // Apply font size
      const fontSize = localStorage.getItem(FONT_SIZE_KEY) || 'text-3xl';
      container.classList.remove('text-2xl', 'text-3xl', 'text-4xl', 'text-5xl');
      container.classList.add(fontSize);
      // Apply mirror mode
      const mirrorEnabled = localStorage.getItem(MIRROR_MODE_KEY) === 'true';
      container.style.transform = mirrorEnabled ? 'scaleX(-1)' : '';
    }

    // Highlight current word and scroll to it
    function highlightCurrentWord() {
      const target = document.getElementById('w' + currentWordIndex);
      if (target) {
        // Remove current highlighting from all words
        document.querySelectorAll('#teleprompter span').forEach(s => s.classList.remove('current'));
        // Highlight current word
      target.classList.add('current');
        // Continuously scroll to keep current word centered
        scrollToCurrentWord();
      }
      // Update button state
      updateStartButton();
    }

    // Continuous smooth scrolling function
    function scrollToCurrentWord() {
      const target = document.getElementById('w' + currentWordIndex);
      const container = document.getElementById('teleprompter');
      
      if (!target || !container) return;
      
      const targetTop = target.offsetTop;
      const containerHeight = container.clientHeight;
      const targetHeight = target.clientHeight;
      
      // Calculate the desired position based on scroll position setting
      let desiredPosition;
      switch (scrollPosition) {
        case 'top':
          desiredPosition = targetTop - (containerHeight * 0.15); // 15% from top
          break;
        case 'bottom':
          desiredPosition = targetTop - (containerHeight * 0.85) + targetHeight; // 85% from top
          break;
        case 'middle':
        default:
          desiredPosition = targetTop - (containerHeight / 2) + (targetHeight / 2); // Centered
          break;
      }
      
      // Get current scroll position
      const currentScroll = container.scrollTop;
      
      // Calculate the difference
      const scrollDiff = desiredPosition - currentScroll;
      
      // Only scroll if there's a meaningful difference (avoid micro-movements)
      if (Math.abs(scrollDiff) > 2) {
        // Smooth continuous scrolling with easing
        const scrollStep = scrollDiff * 0.08; // Smooth and gentle scrolling
        const newScrollTop = currentScroll + scrollStep;
        
        container.scrollTo({
          top: newScrollTop,
          behavior: 'auto' // Use auto for immediate response
        });
      }
    }

    // Start continuous scrolling
    function startContinuousScrolling() {
      if (scrollingInterval) {
        clearInterval(scrollingInterval);
      }
      
      // Continuously adjust scroll position to keep current word centered
      scrollingInterval = setInterval(() => {
        if (isListening && currentWordIndex < words.length) {
          scrollToCurrentWord();
        }
      }, 50); // Update every 50ms for smooth scrolling
    }

    // Stop continuous scrolling
    function stopContinuousScrolling() {
      if (scrollingInterval) {
        clearInterval(scrollingInterval);
        scrollingInterval = null;
      }
    }

    // Mark a word as missed (red highlight)
    function markWordAsMissed(index) {
      if (!highlightEnabled) {
        console.log('Highlighting disabled, skipping missed word marking');
        return; // Skip if highlighting is disabled
      }
      const target = document.getElementById('w' + index);
      if (target) {
        console.log('Marking word as missed:', index, target.textContent);
        target.classList.add('missed');
        target.classList.remove('current');
        // Remove any inline styles
        target.style.backgroundColor = '';
        target.style.color = '';
      } else {
        console.log('Could not find target element for word:', index);
      }
      // Update statistics
      speechStats.missedWords++;
    }

    // Mark a word as mismatched (no highlight - counts as correct in analytics)
    function markWordAsMismatched(index) {
      if (!highlightEnabled) return; // Skip if highlighting is disabled
      const target = document.getElementById('w' + index);
      if (target) {
        target.classList.add('mismatched');
        target.classList.remove('current');
        target.style.backgroundColor = '';
        target.style.color = '';
      }
      // Update statistics (tracked but counted as correct words in analytics)
      speechStats.mismatchedWords++;
    }

    // Clean and normalize word for comparison
    function normalizeWord(word) {
      return word.replace(/[^a-z0-9]/gi, '').toLowerCase();
    }

    // Process speech recognition results
    function processTranscript(transcript) {
      if (!isListening || currentWordIndex >= words.length) return;
      
      const spokenWordsArray = transcript.trim().split(/\s+/);
      const newWords = spokenWordsArray.slice(spokenWords.length);
      
      // Add new words to our spoken words array
      spokenWords.push(...newWords);
      
      // Process each new word
      newWords.forEach(spokenWord => {
        if (currentWordIndex >= words.length) return;
        
        const normalizedSpoken = normalizeWord(spokenWord);
        const normalizedExpected = normalizeWord(words[currentWordIndex]);
        
        if (normalizedSpoken === normalizedExpected) {
          // Word matches current position! Move to next word
          currentWordIndex++;
          if (currentWordIndex >= words.length) {
            stopRecognition();
            showAnalysis();
            return;
          }
          if (currentWordIndex < words.length) {
            highlightCurrentWord();
          }
        } else {
          // Word doesn't match current position, let's be smarter about it
          let foundMatch = false;
          let matchPosition = -1;
          let shouldAdvance = false;
          
          // First, check if this word matches the previous word (we might have missed detecting it before)
          if (currentWordIndex > 0) {
            const normalizedPrevious = normalizeWord(words[currentWordIndex - 1]);
            if (normalizedSpoken === normalizedPrevious) {
              // This word matches the previous word, so we don't need to advance
              foundMatch = true;
              matchPosition = currentWordIndex - 1;
            }
          }
          
          // If not previous word, check if it matches the next word
          if (!foundMatch && currentWordIndex + 1 < words.length) {
            const normalizedNext = normalizeWord(words[currentWordIndex + 1]);
            if (normalizedSpoken === normalizedNext) {
              // This word matches the next word, mark current as missed and advance
              markWordAsMissed(currentWordIndex);
              currentWordIndex += 2; // Skip current and move past the matched word
              if (currentWordIndex < words.length) {
                highlightCurrentWord();
              }
              foundMatch = true;
              matchPosition = currentWordIndex - 1;
              shouldAdvance = true;
            }
          }
          
          // If still no match, check a few words ahead (skip detection)
          if (!foundMatch) {
            for (let i = currentWordIndex + 2; i < Math.min(currentWordIndex + 7, words.length); i++) {
              if (normalizeWord(words[i]) === normalizedSpoken) {
                // Mark skipped words as missed
                for (let j = currentWordIndex; j < i; j++) {
                  markWordAsMissed(j);
                }
                currentWordIndex = i + 1;
                if (currentWordIndex < words.length) {
                  highlightCurrentWord();
                }
                foundMatch = true;
                matchPosition = i;
                shouldAdvance = true;
                break;
              }
            }
          }
          
          // If still no match found, check if it's a word we've already passed (check all previous words)
          if (!foundMatch && currentWordIndex >= 2) {
            for (let i = 0; i < currentWordIndex - 1; i++) {
              if (normalizeWord(words[i]) === normalizedSpoken) {
                // Word matches something we already passed, ignore it (don't advance)
                foundMatch = true;
                matchPosition = i;
                
                // Clear mismatched highlights from the found position forward (user may have gone back to repeat)
                clearMismatchedHighlightsForward(i);
                break;
              }
            }
          }
          
          // Only mark as mismatched if we truly couldn't find it anywhere in our ranges
          if (!foundMatch) {
            // No match found anywhere in reasonable range, mark current word as mismatched and advance
            markWordAsMismatched(currentWordIndex);
            currentWordIndex++;
            if (currentWordIndex < words.length) {
              highlightCurrentWord();
            }
          }
        }
      });
    }

    // Stop speech recognition
    function stopRecognition() {
      if (recognition) {
        recognition.stop();
        recognition = null;
      }
      isListening = false;
      stopContinuousScrolling();
      
      // Set end time if not already set
      if (speechStats.endTime === null) {
        speechStats.endTime = new Date();
      }
      
      // Update button state
      updateStartButton();
    }

    // Initialize Web Speech API
    function startRecognition(isResume = false) {
      const Speech = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!Speech) {
        alert('Your browser does not support Web Speech API. Please use Chrome or Edge.');
        return;
      }

      recognition = new Speech();
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.continuous = true;

      recognition.onresult = e => {
        let transcript = '';
        for (const r of e.results) {
          transcript += r[0].transcript + ' ';
        }
        processTranscript(transcript);
      };

      recognition.onerror = e => {
        console.error('Speech recognition error:', e);
        stopRecognition();
      };

      recognition.onend = () => {
        isListening = false;
        stopContinuousScrolling();
        // Set end time if not already set
        if (speechStats.endTime === null) {
          speechStats.endTime = new Date();
        }
        updateStartButton();
      };

      recognition.start();
      
      // Set listening state and reset speech buffer
      isListening = true;
      spokenWords = [];
      
      // Only reset position if this is a fresh start, not a resume
      if (!isResume) {
        currentWordIndex = 0;
        // Reset start time for fresh start
        speechStats.startTime = new Date();
        speechStats.endTime = null;
      }
      
      // Highlight current word (whether fresh start or resume)
      highlightCurrentWord();
      
      // Start continuous scrolling to keep text centered
      startContinuousScrolling();
      
      // Button text is handled by updateStartButton() in highlightCurrentWord()
    }

    // Toggle speech recognition
    function toggleRecognition() {
      const startBtn = document.getElementById('startBtn');
      
      if (startBtn.textContent === 'View Analysis') {
        // Show analysis modal
        showAnalysis();
      } else if (isListening) {
        stopRecognition();
      } else {
        // Check if we're resuming (currentWordIndex > 0) or starting fresh
        const isResume = currentWordIndex > 0 && currentWordIndex < words.length;
        startRecognition(isResume);
      }
    }

    // Event listeners
    document.getElementById('startBtn').addEventListener('click', toggleRecognition);

    // Script textarea event listener for real-time stats
    document.addEventListener('DOMContentLoaded', () => {
      // Load saved theme on page load
      loadTheme();
      
      const scriptTextarea = document.getElementById('script-text');
      if (scriptTextarea) {
        scriptTextarea.addEventListener('input', () => {
          updateScriptStats();
          // Save script to localStorage as user types
          localStorage.setItem(STORAGE_KEY, scriptTextarea.value);
        });
      }
      
      // Load URL button event listener
      const loadUrlBtn = document.getElementById('load-url-btn');
      if (loadUrlBtn) {
        loadUrlBtn.addEventListener('click', () => {
          const urlInput = document.getElementById('script-url');
          const url = urlInput.value.trim();
          
          if (!url) {
            showError('Please enter a valid URL or file path');
            return;
          }
          
          // Load the script
          loadScriptFromURL(url);
          // Save the URL to localStorage
          localStorage.setItem('teleprompter_url', url);
        });
      }
      
      // Allow Enter key to trigger URL loading and save URL to localStorage
      const urlInput = document.getElementById('script-url');
      if (urlInput) {
        // Load saved URL
        const savedUrl = localStorage.getItem('teleprompter_url');
        if (savedUrl) {
          urlInput.value = savedUrl;
        }
        
        urlInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            document.getElementById('load-url-btn').click();
          }
        });
        
        // Save URL to localStorage as user types
        urlInput.addEventListener('input', () => {
          localStorage.setItem('teleprompter_url', urlInput.value);
        });
      }
      
      // File loading functionality
      const loadFileBtn = document.getElementById('load-file-btn');
      const fileInput = document.getElementById('script-file');
      
      if (loadFileBtn && fileInput) {
        loadFileBtn.addEventListener('click', () => {
          fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            loadScriptFromFile(file);
          }
        });
      }
      
      // Check for script parameter in URL and auto-load
      checkForScriptParameter();
    });

    // Check URL parameters for automatic script loading
    function checkForScriptParameter() {
      const urlParams = new URLSearchParams(window.location.search);
      const scriptUrl = urlParams.get('script');
      
      if (scriptUrl) {
        // Auto-load the script from the URL parameter
        loadScriptFromURL(scriptUrl);
        
        // Update the URL input field to show what was loaded
        const urlInput = document.getElementById('script-url');
        if (urlInput) {
          urlInput.value = scriptUrl;
          // Save the URL to localStorage
          localStorage.setItem('teleprompter_url', scriptUrl);
        }
      }
    }

    // Advanced settings navigation
    document.addEventListener('DOMContentLoaded', () => {
      const advToggle = document.getElementById('advanced-settings-toggle');
      if (advToggle) {
        advToggle.addEventListener('click', () => {
          showScreen('advanced-settings');
        });
      }
      // Reset to Defaults button
      const resetBtn = document.getElementById('reset-defaults');
      if (resetBtn) {
        resetBtn.addEventListener('click', function(e) {
          e.preventDefault();
          // Remove all relevant keys from localStorage
          localStorage.removeItem('teleprompter_theme');
          localStorage.removeItem('teleprompter_font_size');
          localStorage.removeItem('teleprompter_scroll_position');
          localStorage.removeItem('teleprompter_highlight_enabled');
          localStorage.removeItem('teleprompter_mirror_mode');
          localStorage.removeItem('teleprompter_url');

          // Add more keys as needed for new settings
          // Reset UI to defaults
          loadFontSize();
      loadScrollPosition();
      loadHighlightEnabled();
          loadMirrorMode();

          applyTheme(getSystemTheme());
          // Optionally show a confirmation
          alert('Settings have been reset to defaults.');
        });
      }
    });
  </script>
</body>
</html>
